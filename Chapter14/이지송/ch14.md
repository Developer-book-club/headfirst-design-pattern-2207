## 책임 연쇄 패턴 (Chain of Responsibility Pattern)

> **책임 연쇄 패턴 (Chain of Responsibility Pattern)** 은 클라이언트로부터 요청을 처리할 수 있는 객체들을 느슨하게 연결한 집합(Chain) 을 제공한다. 이 패턴은 본질적으로 특정 요청을 처리할 수 있는 객체에 대한 선형 검색(linear search)이다.

### 책임 연쇄 패턴이 적용되는 경우

- 요청의 발신자와 수신자를 분리하는 경우
- 요청을 처리할 수 있는 객체가 여러개일 때 그 중 하나에 요청을 보내려는 경우
- 코드에서 처리객체(handler)를 명시적으로 지정하고 싶지 않은 경우

### 장점

- 결합도를 낮추며, 요청의 발신자와 수신자를 분리시킬 수 있다.
- 클라이언트는 처리 객체의 집합 내부 구조를 알 필요가 없다.
- 집합 내의 처리 순서를 변경하거나 처리 객체를 추가 또는 삭제할 수 잇어 유연성이 향상된다.
- 새로운 요청에 대한 처리 객체 생성이 매우 편리해진다.

### 단점

- 충분한 디버깅을 거치지 않았을 경우 집합 내부에서 사이클이 발생할 수 있다.
- 디버깅 및 테스트가 쉽지 않다.

###

```javascript
class ShoppingCart {
  constructor() {
    this.products = [];
  }

  addProduct(product) {
    this.products.push(product);
  }
}

class Discount {
  constructor() {}

  calcurate(products) {
    const numberDiscount = new NumberDiscount();
    const priceDiscount = new PriceDiscount();
    const noneDiscount = new NoneDiscount();
    numberDiscount.setNext(priceDiscount);
    priceDiscount.setNext(noneDiscount);
    return numberDiscount.execute(products);
  }
}

class NumberDiscount {
  constructor() {
    this.next = null;
  }

  setNext(fn) {
    this.next = fn;
  }

  execute(products) {
    let result = 0;
    if (products.length > 3) result = 0.05;
    if (this.next) result += this.next.execute(products);

    return result;
  }
}
class PriceDiscount {
  constructor() {
    this.next = null;
  }

  setNext(fn) {
    this.next = fn;
  }

  execute(products) {
    let result = 0;
    let total = products.reduce((a, b) => a + b);

    if (total >= 500) result = 0.1;
    if (this.next) result += this.next.execute(products);

    return result;
  }
}

class NoneDiscount {
  execute() {
    return 0;
  }
}
```

### Chaining Pattern

책임 체인의 예는 이벤트를 처리하도록 선택할 수 있는 일련의 중첩된 제어를 통해 이벤트가 전파되는 이벤트 버블링(event-bubbling)이다.
책임 연쇄 패턴은 JavaScript에서 자주 사용되는 Chaining Pattern과 관련이 있다. (jQuery는 이 패턴을 광범위하게 사용합니다).

아래 예제는 하나가 아니라 모든 핸들러가 요청에 참여한다는 점에서 고전적인 책임 연쇄 패턴과는 다르다.

```javascript
class Request {
  constructor(amount) {
    this.amount = amount;
  }

  get(bill) {
    const count = Math.floor(this.amount / bill);
    this.amount -= count * bill;
    return this;
  }
}

const request = new Request(378);
request.get(100).get(50).get(20).get(10);
```

## 플라이웨이트 패턴 (Flyweight Pattern)

> **플라이웨이트 패턴 (Flyweight Pattern)** 은 많은 수의 세분화된 객체들을 효율적으로 공유하여 메모리를 절약한다. 다른 객체들을 공유하는 특성을 나타내기 때문에 플라이웨이트 객체는 불변적(immutable)이다.

### 플라이웨이트 패턴이 적용되는 경우

플라이웨이트 패턴은 본질적으로 "객체 정규화 기법"이다. (참고: 이 아이디어는 모델러가 중복성을 최소화하려고 시도하는 프로세스인 데이터 모델 정규화와 유사하다.)

예시로는 애플리케이션 간에 공유되는 불변 문자열 목록을 유지하는 JavaScript 엔진 자체 내에 있다.

다른 예로는 워드 프로세서의 문자 및 라인 스타일, 또는 공중 교환 전화망 애플리케이션의 '디지털 수신기' 등이 있다. 플라이웨이트는 주로 워드 프로세서, 그래픽 프로그램 및 네트워크 앱과 같은 유틸리티 유형 애플리케이션에서 발견되며, 데이터 기반(data-driven) 비즈니스 유형 애플리케이션에서는 덜 사용된다.

### 장점

- 실행 시에 객체 인스턴의 개수를 줄여서 메모리를 절약할 수 있다.
- 여러 가상 객체의 상태를 한 곳에 모아둘 수 있다.

### 단점

- 특정 인스턴스만 다른 인스턴스처럼 동작하도록 하는 것이 불가능하다.
- 객체의 값을 변경하면 공유받은 가상 객체를 사용하는 곳에 영향을 줄 수 있다.

```javascript
class Color {
  constructor(name) {
    this.name = name;
  }
}

class colorFactory {
  constructor(name) {
    this.colors = {};
  }

  create(name) {
    let color = this.colors[name];
    if (color) return color;
    this.colors[name] = new Color(name);
    return this.colors[name];
  }
}
```

## 인터프리터 패턴 (Interpreter Pattern)

> **인터프리터 패턴 (Interpreter Pattern)** 은 최종 사용자가 솔루션을 사용자 정의할 수 있는 스크립트 언어를 제공한다. 문법 규칙을 클래스화 한 구조로, 일련의 규칙으로 정의된 문법적 언어를 해석하는 패턴이다.(SQL, SHELL...) 인터프리터 패턴은 SQL과 같은 계층적 언어를 해석하기 위해 계층 구조를 표현할 수 있습니다.

### 인터프리터 패턴이 적용되는 경우

일부 응용 프로그램은 너무 복잡하여 고급 구성이 필요하다. 최종 사용자가 간단한 지침을 통해 애플리케이션을 조작할 수 있도록 하는 기본 스크립트 언어를 제공할 수 있다. 인터프리터 패턴은 이 특정 문제, 즉 간단한 스크립트 언어를 만드는 문제를 해결한다.

어떤 종류의 문제들은 언어에 의해 특징 지어진다. 이를 구현하려면 언어를 문법에 매핑해야 한다. 문법은 일반적으로 여러 단계를 거쳐 단말 노드(리터럴이라고도 함)로 끝나는 계층적 트리와 같은 구조이다.

문법으로 표현되는 이와 같은 문제는 인터프리터 디자인 패턴을 사용하여 구현할 수 있다.

오늘날, 자바스크립트에서 이런 종류의 제어가 정말로 필요하다면, 제공하려는 문법을 기반으로 자신의 명령 인터프리터를 만들 수 있게 해주는 ANTLR과 같은 코드 생성기를 사용하는 것이 더 쉬울 것이다.

### 구조

- 클라이언트
  - 코드를 실행한다 (interpret() 를 호출한다)
- Context
  - String 표현식이어야 하며, 인터프리터에 보내는 정보다.
- TerminalExpression
  - Terminal 기호와 관련된 interpret()를 구현한다.
- NonTerminalExpression
  - NonTerminal 기호와 관련된 interpret()를 구현한다.

### 장점

- 문법의 추가 및 수정, 구현이 쉬워진다.

### 단점

- 복잡한 문법의 경우 관리 및 유지가 어려워진다.

```javascript
// 로마 숫자를 10진수로 변환하는 인터프리터
class Context {
  constructor(input) {
    this.input = input;
    this.output = 0;
  }

  startsWith(str) {
    return this.input.substr(0, str.length) === str;
  }
}

class Expression {
  constructor(name, one, four, five, nine, multiplier) {
    this.name = name;
    this.one = one;
    this.four = four;
    this.five = five;
    this.nine = nine;
    this.multiplier = multiplier;
  }

  interpret(context) {
    if (context.input.length == 0) {
      return;
    } else if (context.startsWith(this.nine)) {
      context.output += 9 * this.multiplier;
      context.input = context.input.substr(2);
    } else if (context.startsWith(this.four)) {
      context.output += 4 * this.multiplier;
      context.input = context.input.substr(2);
    } else if (context.startsWith(this.five)) {
      context.output += 5 * this.multiplier;
      context.input = context.input.substr(1);
    }
    while (context.startsWith(this.one)) {
      context.output += 1 * this.multiplier;
      context.input = context.input.substr(1);
    }
  }
}

// IN APP
var roman = "MCMXXVIII";
var context = new Context(roman);
var tree = [];

tree.push(new Expression("thousand", "M", " ", " ", " ", 1000));
tree.push(new Expression("hundred", "C", "CD", "D", "CM", 100));
tree.push(new Expression("ten", "X", "XL", "L", "XC", 10));
tree.push(new Expression("one", "I", "IV", "V", "IX", 1));

for (var i = 0, len = tree.length; i < len; i++) {
  tree[i].interpret(context);
}

console.log(roman + " = " + context.output);
```

## 중재자 패턴 (Mediator Pattern)

> **중재자 패턴 (Mediator Pattern)** 은 객체들 간의 상호작용 행위를 정리하여 모든 중재자 객체를 따로 두어 관리하는 디자인 패턴이다. 이 모델은 모든 객체가 그룹에 있는 다른 객체의 상태 변경을 인식해야 하는 복잡한 조건을 관리해야 하는 시나리오에 유용하다.

### 중재자 패턴이 적용되는 경우

중재자 패턴은 복잡한 형태의 개발에 유용하다.

항공편 예약 옵션을 입력하는 페이지를 예로 들면, 간단한 중재자 규칙은 다음과 같다.

- 유효한 출발 날짜 / 귀국 날짜
- 귀국날짜는 출발 날짜 이후여야 한다.
- 유효한 출발 공항 / 도착 공항
- 필요한 좌석 수

이 조건들을 만족해야 검색 버튼을 활성화시켜야 한다.

또 다른 예시는 비행기의 도착과 출발을 조정하는 공항의 관제탑이다.

### 구조

- Mediator
  - Colleague 객체간의 상호작용을 위한 인터페이스를 정의한다.
  - Colleague 객체에 대한 참조를 관리한다.
  - 운영에 대한 중앙 제어를 관리한다.
- Colleague
  - 다른 Colleague와의 상호작용을 위한 인터페이스를 정의한다.
  - Mediator 에 의해 중재된다
  - 각 인스턴스는 중재자에 대한 참조를 유지한다.

### 장점

- 객체들 간 수정을 하지않고 관계를 수정할 수 있다.
- 객체들간의 관계의 복잡도, 의존성 및 결합도를 감소시킨다.

### 단점

- 중재자 패턴 사용 시 중재자 객체에 권한이 집중화되어 굉장히 크며 복잡해지므로, 설계 및 중재자 객체 수정 시 주의해야 한다.

```javascript
// Mediator: Chatroom
// Colleague: Participant

class Participant {
  constructor(name) {
    this.name = name;
    this.chatroom = null;
  }

  send(message, to) {
    this.chatroom.send(message, this, to);
  }

  receive(message, from) {
    console.log(from.name + " to " + this.name + ": " + message);
  }
}

class Chatroom {
  constructor() {
    this.participants = {};
  }

  register(participant) {
    participants[participant.name] = participant;
    participant.chatroom = this;
  }

  send(message, from, to) {
    if (to) {
      // single message
      to.receive(message, from);
    } else {
      // broadcast message
      for (key in participants) {
        if (participants[key] !== from) {
          participants[key].receive(message, from);
        }
      }
    }
  }
}

// In App
const yoko = new Participant("Yoko");
const john = new Participant("John");
const paul = new Participant("Paul");
const ringo = new Participant("Ringo");

const chatroom = new Chatroom();
chatroom.register(yoko);
chatroom.register(john);
chatroom.register(paul);
chatroom.register(ringo);

yoko.send("All you need is love.");
yoko.send("I love you John.");
john.send("Hey, no need to broadcast", yoko);
paul.send("Ha, I heard that!");
ringo.send("Paul, what do you think?", paul);
```
